<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.46" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>Автоматический деплой приложений &middot; ДХ</title>
  
  <meta name="description" content="В этой заметке пойдёт речь об автоматизации выкладки приложений на удалённые серверы и базовое управление процессами.
Проблематика Обычно у админа есть нес" />
  <meta name="keywords" content="блог, программирование, технологии, гаджеты, фото, путешествия, обзоры, гайды, видеоигры">
  <meta name="author" content="Дмитрий Храпонов">


  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@snupt"/>


  <meta property="og:title" content="Автоматический деплой приложений" />
  <meta property="og:description" content="В этой заметке пойдёт речь об автоматизации выкладки приложений на удалённые серверы и базовое управление процессами.
Проблематика Обычно у админа есть несколько задач связанных с работой приложений на удалённых серверах:
 Доставка, установка приложения и его зависимостей Доставка контента Доставка служебных файлов  Конфиги Сертификаты Скрипты Переменные окружения И так далее  Администрирование сервера  Создание и настройка учётных записей Управление сервисами Обновление приложений И так далее   Это набор довольно типичных задач, но их объём может варьироваться в зависимости от требований." />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="https://snupt.com/blog/deployment-automation-tools/" />
  <meta property="og:image" content="https://snupt.com/images/general/cover.png" />
  <meta property="og:locale" content="ru_RU" />
  

  <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Автоматический деплой приложений",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://snupt.com/blog/deployment-automation-tools/"
  },
  "image": {
    "@type": "ImageObject",
    "url": "https://snupt.com/images/general/cover.png"
  },
  "genre": "blog",
  "wordCount": 1753,
  "url": "https://snupt.com/blog/deployment-automation-tools/",
  "datePublished": "2018-08-08T11:57:44+03:00",
  "dateModified": "2018-08-10T20:00:00+03:00",
  "publisher": {
    "@type": "Organization",
    "name": "Дмитрий Храпонов",
    "logo": {
      "@type": "ImageObject",
      "url": "https://snupt.com/images/general/avatar.png"
    }
  },
  "author": {
    "@type": "Person",
    "name": "Дмитрий Храпонов"
  },
  "description": "В этой заметке пойдёт речь об автоматизации выкладки приложений на удалённые серверы и базовое управление процессами.
Проблематика Обычно у админа есть несколько задач связанных с работой приложений на удалённых серверах:
 Доставка, установка приложения и его зависимостей Доставка контента Доставка служебных файлов  Конфиги Сертификаты Скрипты Переменные окружения И так далее  Администрирование сервера  Создание и настройка учётных записей Управление сервисами Обновление приложений И так далее   Это набор довольно типичных задач, но их объём может варьироваться в зависимости от требований."
}
</script>


  <link type="text/css" rel="stylesheet" href="https://snupt.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://snupt.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://snupt.com/css/hyde.css">
  <link href="https://fonts.googleapis.com/css?family=Yeseva+One%7CFira+Mono%7CPT+Sans:400,400i,700;subset=cyrillic,cyrillic-ext,latin-ext" rel="stylesheet">



  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
  <link rel="manifest" href="/favicons/site.webmanifest">
  <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#000000">
  <link rel="shortcut icon" href="/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-config" content="/favicons/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">

  
  <link href="https://snupt.com/blog/index.xml" rel="alternate" type="application/rss+xml" title="ДХ: Блог" />

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
<link type="text/css" rel="stylesheet" href="https://snupt.com/css/my.css">

</head>

  
  <body>
  <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a style="text-decoration: none" href="https://snupt.com/"><h1>ДХ</h1></a>
      
      <p class="lead">
       Авторский проект Дмитрия Храпонова 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://snupt.com/">Главная</a> </li>
      <li><a href="/blog/"> Блог </a></li><li><a href="/about/"> Обо мне </a></li>
      <li><p></p></li>
      
      
      <li><a href="mailto:snupt@snupt.com"> Почта </a></li><li><a href="https://twitter.com/snupt/"> Твиттер </a></li><li><a href="https://telegram.me/snupt"> Телеграм </a></li><li><a href="https://instagram.com/snupt"> Инстаграм </a></li><li><a href="https://github.com/snupt"> Гитхаб </a></li>
      
    </ul>

    <p><a href="/blog/index.xml"><span class="fas fa-rss"></span></a></p>

    <form id="searchform" method="get" action="https://www.google.com/search">
    <p><input type="text" name="q" placeholder="Поиск по сайту" style="text-align: inherit; font-size: inherit; font-family: inherit;" /></p>
    <input type="hidden" name="sitesearch" value="https://snupt.com/" /></form>

    
    <p>&copy; 2018. Все права защищены. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>Автоматический деплой приложений</h1>
  <span class="post-date">Aug 8, 2018</span>
  

<p>В этой заметке пойдёт речь об автоматизации выкладки приложений на удалённые серверы и базовое управление процессами.</p>

<h2 id="проблематика">Проблематика</h2>

<p>Обычно у админа есть несколько задач связанных с работой приложений на удалённых серверах:</p>

<ul>
<li>Доставка, установка приложения и его зависимостей</li>
<li>Доставка контента</li>
<li>Доставка служебных файлов

<ul>
<li>Конфиги</li>
<li>Сертификаты</li>
<li>Скрипты</li>
<li>Переменные окружения</li>
<li>И так далее</li>
</ul></li>
<li>Администрирование сервера

<ul>
<li>Создание и настройка учётных записей</li>
<li>Управление сервисами</li>
<li>Обновление приложений</li>
<li>И так далее</li>
</ul></li>
</ul>

<p>Это набор довольно типичных задач, но их объём может варьироваться в зависимости от требований.</p>

<p>Возьмём к примеру установку и администрирование простого почтового сервера на базе Postfix. Представьте объём работы, которую надо проделать для того чтоб поставить полноценный почтовый сервер. Необходимо настроить базовую функциональность, прикрутить антиспам, антивирус, сгенерировать сертификаты, ключи шифрования, фильтрацию обработки почты и обеспечить безопасность. По разным прикидкам у человека который делает это впервые может уйти до недели. А что если надо мигрировать на другой сервер? То есть задача повторить тоже самое, но в другом месте и возможно даже на другой операционной системе. Сможете вспомнить всё что надо сделать? Сомневаюсь. Всегда есть риск ошибиться, погрязнуть в зависимостях, конфигах, забыть настроить бекапы, безопасность, ещё что-то. Или вот другой случай, поделиться настройками с кем-то ещё. Вы заливаете все конфиги в гитхаб, кто-то их скачивает, но у него ничего не работает из-за отличий в системном окружении. А если работа идёт в команде и делиться надо постоянно? Ну, вы поняли.</p>

<p>Ранее традиционными способами решения таких проблем были скрипты. Однако, писать скрипты под каждую задачу это сложно и долго. На сегодняшний день подобные задачи принято решать через инструменты <a href="https://ru.wikipedia.org/wiki/Конфигурационное_управление">конфигурационного управления</a>. Одним из таких инструментов является продукт компании Red Hat — <a href="https://ru.wikipedia.org/wiki/Ansible">Ansible</a>. Главное его отличие от аналогов в том, что не нужна установка агента/клиента на целевые системы. Ну а использование декларативного языка разметки для описания конфигураций даёт низкий порог вхождения.</p>

<h2 id="установка">Установка</h2>

<p>В macOS его можно установить через <a href="https://brew.sh">brew</a>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ brew install ansible</code></pre></div>
<p>Либо через python pip:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ sudo easy_install pip
$ sudo -H pip install ansible</code></pre></div>
<p>Ansible представляет из себя набор связанных модулей, работа с которыми описывается конфигурационными файлами в формате <a href="https://ru.wikipedia.org/wiki/YAML">YAML</a>. Продукт прекрасно документирован <a href="https://docs.ansible.com/ansible/latest/index.html">Ansible Documentation</a>.</p>

<h2 id="демонстрационный-проект">Демонстрационный проект</h2>

<p>Давайте создадим типовой проект конечной целью которого будет публикация простого веб приложения на vps хостинг. Я заранее создал дроплет в Digital Ocean с предустановленной Ubuntu Server 18.04 в базовой конфигурации для демонстрации возможностей Ansible.</p>

<p>Предлагаю разбить проект на два этапа. На первом подготовим сервер к боевым задачам:</p>

<ul>
<li>Создание пользователя</li>
<li>Смена часового пояса</li>
<li>Обновление пакетов до последних версий</li>
<li>Установка Docker</li>
</ul>

<p>На втором произведём деплой приложения и настроим менеджмент вокруг него:</p>

<ul>
<li>Доставка приложения</li>
<li>Управление состоянием</li>
<li>Резервное копирование данных</li>
</ul>

<h3 id="структура">Структура</h3>

<p>Подсматриваем в <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html">Best Practices</a> и делаем соответствующую разметку:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">group_vars/         # общие переменные
  all/
    vars.yml
    vault.yml
roles/
  common/           # менеджмент сервера
    tasks/
      main.yml
  blog/             # веб приложение 
    files/
    tasks/
      main.yml
inventory.ini       # список хостов
playbook.yml        # плейбук</code></pre></div>
<p>Запишем в <code>inventory.ini</code> данные необходимые для подключения к серверу:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ini" data-lang="ini"><span style="color:#007020;font-weight:bold">[webserver]</span>
<span style="color:#4070a0">178.128.207.139 ansible_user</span><span style="color:#666">=</span><span style="color:#4070a0">snupt ansible_port=22 ansible_python_interpreter=&#34;/usr/bin/env python3&#34;</span></code></pre></div>
<p>Группу хостов назовём <code>webserver</code>. В этом примере сервер один, но на практике их может быть сколько угодно. Пользователя <code>snupt</code> на сервере ещё не существует, но не волнуйтесь, мы решим эту задачу чуть позже. По умолчанию Ansible использует Python2, а в Ubuntu 18.04 установлен только Python3, поэтому нам нужно поменять это принудительно через переменную <code>ansible_python_interpreter</code>.</p>

<p>Все задачи можно описывать прямиком в плейбуке, но если их много и приложение не одно, то хорошей практикой является использование так называемых ролей. Роли помогают группировать задачи.</p>

<h3 id="создание-пользователя">Создание пользователя</h3>

<p>Давайте подготовимся к процессу создания учётной записи. Объявим переменные с содержанием имени пользователя и пароля. С именем всё просто, оно хранится в текстовом виде, а вот пароль, следуя <a href="https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#how-do-i-generate-crypted-passwords-for-the-user-module">документации</a> нужно передавать в зашифрованном виде.</p>

<p>В macOS это делается следующим образом:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ sudo -H pip install passlib
$ python -c <span style="color:#4070a0">&#34;from passlib.hash import sha512_crypt; import getpass; print(sha512_crypt.using(rounds=5000).hash(getpass.getpass()))&#34;</span></code></pre></div>
<p>Общие переменные хранятся в каталоге <code>group_vars/all/</code>. Запишем в файл <code>vars.yml</code> переменную с именем пользователя:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">username:<span style="color:#bbb"> </span>snupt</code></pre></div>
<p>А в файл <code>vault.yml</code> переменную с паролем:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">user_password:<span style="color:#bbb"> </span>$<span style="color:#40a070">6</span>$smd6jF7Z5Ze9sWgF$56SxnDUaQ79GMIcVWDRIERSTKEKE103WOcFQLNvsGijlFcxWRJz1vrVWRwOqsg6xGkYF94ePUXuQISRITgVzI1</code></pre></div>
<p>Для администрирования пользователей Ansible предлагает использовать модуль <a href="http://docs.ansible.com/ansible/latest/modules/user_module.html#user-module">user</a>. Откройте документацию, посмотрите секцию возможных параметров и примеры использования. Помимо создания пользователя нам желательно бы сразу настроить авторизацию по ключу. Для этого также есть подходящий модуль <a href="http://docs.ansible.com/ansible/latest/modules/authorized_key_module.html#authorized-key-module">authorized_key</a>. Воспользуемся модулем <a href="https://docs.ansible.com/ansible/latest/modules/lineinfile_module.html">lineinfile</a> для редактирования файла sudoers и заставим sudo не просить пароль у всех кто в группе admin.</p>

<p>Создаём файл <code>roles/common/tasks/useradd.yml</code> со следующей информацией:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>create<span style="color:#bbb"> </span>new<span style="color:#bbb"> </span>user<span style="color:#bbb">
</span><span style="color:#bbb">  </span>user:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ username }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>password:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ user_password }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>shell:<span style="color:#bbb"> </span>/bin/bash<span style="color:#bbb">
</span><span style="color:#bbb">    </span>groups:<span style="color:#bbb"> </span>admin<span style="color:#bbb">
</span><span style="color:#bbb">    </span>append:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>set<span style="color:#bbb"> </span>authorized<span style="color:#bbb"> </span>key<span style="color:#bbb"> </span>taken<span style="color:#bbb"> </span>from<span style="color:#bbb"> </span>file<span style="color:#bbb">
</span><span style="color:#bbb">  </span>authorized_key:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>user:<span style="color:#bbb"> </span>snupt<span style="color:#bbb">
</span><span style="color:#bbb">    </span>state:<span style="color:#bbb"> </span>present<span style="color:#bbb">
</span><span style="color:#bbb">    </span>key:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ lookup(&#39;file&#39;, &#39;~/.ssh/id_rsa.pub&#39;) }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>allow<span style="color:#bbb"> </span>admin<span style="color:#bbb"> </span>group<span style="color:#bbb"> </span>to<span style="color:#bbb"> </span>have<span style="color:#bbb"> </span>passwordless<span style="color:#bbb"> </span>sudo<span style="color:#bbb">
</span><span style="color:#bbb">  </span>lineinfile:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>path:<span style="color:#bbb"> </span>/etc/sudoers<span style="color:#bbb">
</span><span style="color:#bbb">    </span>regexp:<span style="color:#bbb"> </span><span style="color:#4070a0">&#39;^%admin&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>line:<span style="color:#bbb"> </span><span style="color:#4070a0">&#39;%admin ALL=(ALL) NOPASSWD: ALL&#39;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>validate:<span style="color:#bbb"> </span><span style="color:#4070a0">&#39;/usr/sbin/visudo -cf %s&#39;</span></code></pre></div>
<p>По умолчанию роль выполнит всё, что описано в файле <code>../tasks/main.yml</code>, но наши таски находятся в <code>../tasks/useradd.yml</code>. Можно было и не создавать отдельный файл, но сделав это мы можем импортировать его куда угодно при помощи модуля <a href="http://docs.ansible.com/ansible/latest/modules/import_tasks_module.html#import-tasks-module">import_tasks</a>. Таким образом, в ряде случаев, нам не придётся дублировать уже написанный код, а также иметь возможность работать с импортируемыми данными как с отдельным слоем абстракции. Импортируем <code>useradd.yml</code> в <code>main.yml</code> и попросим Ansible выполнить эти задачи от имени пользователя <code>root</code>, так как в <code>inventory.ini</code> указан пока ещё несуществующий пользователь:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>useradd.yml<span style="color:#bbb">
</span><span style="color:#bbb">  </span>vars:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>ansible_user:<span style="color:#bbb"> </span>root</code></pre></div>
<p>Последующие задачи будем вносить по этой же схеме, поэтому давайте создадим файлы в <code>roles/common/tasks/</code> с описанием задач, а затем импортируем их в <code>main.yml</code> как показано на примере выше.</p>

<h3 id="смена-часового-пояса">Смена часового пояса</h3>

<p>Для смены временной зоны на сервере можно использовать модуль модуль <a href="http://docs.ansible.com/ansible/latest/modules/timezone_module.html#timezone-module">timezone</a>. Создадим файл <code>timezone.yml</code> со следующим кодом:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>set<span style="color:#bbb"> </span>timezone<span style="color:#bbb">
</span><span style="color:#bbb">  </span>timezone:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>Europe/Moscow</code></pre></div>
<h3 id="обновление-пакетов">Обновление пакетов</h3>

<p>Установка и удаление пакетов в Ubuntu делается через модуль <a href="http://docs.ansible.com/ansible/latest/modules/apt_module.html#apt-module">apt</a>. Обновим кеш, поставим все обновления и почистим оставшийся мусор. Опишем всё это в файле <code>upgrade.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>upgrade<span style="color:#bbb"> </span>all<span style="color:#bbb"> </span>packages<span style="color:#bbb"> </span>to<span style="color:#bbb"> </span>the<span style="color:#bbb"> </span>latest<span style="color:#bbb"> </span>version<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;*&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>state:<span style="color:#bbb"> </span>latest<span style="color:#bbb">
</span><span style="color:#bbb">    </span>update_cache:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">    </span>autoremove:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">    </span>autoclean:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">    </span>force_apt_get:<span style="color:#bbb"> </span>yes</code></pre></div>
<h3 id="установка-docker">Установка Docker</h3>

<p><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Инструкция по установке Docker</a> предлагает подключить официальный репозиторий. Для этого потребуется применить модули <a href="http://docs.ansible.com/ansible/latest/modules/apt_key_module.html#apt-key-module">apt_key</a>, <a href="http://docs.ansible.com/ansible/latest/modules/apt_repository_module.html#apt-repository-module">apt_repository</a> и уже знакомый нам apt. А также добавить нашего пользователя в группу <code>docker</code>. Все этим задачи можно объединить в одном файле <code>docker.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>add<span style="color:#bbb"> </span>docker’s<span style="color:#bbb"> </span>official<span style="color:#bbb"> </span>gpg<span style="color:#bbb"> </span>key<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt_key:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>url:<span style="color:#bbb"> </span>https://download.docker.com/linux/ubuntu/gpg<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>add<span style="color:#bbb"> </span>docker’s<span style="color:#bbb"> </span>official<span style="color:#bbb"> </span>reposytory<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt_repository:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>repo:<span style="color:#bbb"> </span>deb<span style="color:#bbb"> </span>https://download.docker.com/linux/ubuntu<span style="color:#bbb"> </span>bionic<span style="color:#bbb"> </span>stable<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>install<span style="color:#bbb"> </span>docker<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ packages }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>update_cache:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">  </span>vars:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>packages:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>docker-ce<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>docker-compose<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>add<span style="color:#bbb"> </span>user<span style="color:#bbb"> </span>to<span style="color:#bbb"> </span>docker<span style="color:#bbb"> </span>group<span style="color:#bbb">
</span><span style="color:#bbb">  </span>user:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ username }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>groups:<span style="color:#bbb"> </span>docker<span style="color:#bbb">
</span><span style="color:#bbb">    </span>append:<span style="color:#bbb"> </span>yes</code></pre></div>
<p>Сразу желательно учесть, что для взаимодействия Ansible и Docker нужны соответствующие модули, которые ставятся через менеджер пакетов Python. Если этого не сделать, то при запуске плейбука будут ошибки с предложением поставить их. Можно создать отдельный файл, но правильней будет держать всю логику связанную с установкой Docker в одном месте, поэтому просто допишем в <code>docker.yml</code> следующий код:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>install<span style="color:#bbb"> </span>dependencies<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>python3-pip<span style="color:#bbb">
</span><span style="color:#bbb">    </span>update_cache:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>install<span style="color:#bbb"> </span>docker<span style="color:#bbb"> </span>modules<span style="color:#bbb">
</span><span style="color:#bbb">  </span>pip:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ item }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>with_items:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>docker<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>docker-compose</code></pre></div>
<h3 id="выполнение-роли-common">Выполнение роли Common</h3>

<p>Импортируем все вышеперечисленные таски в том порядке, в котором они будут выполняться. Итоговый файл <code>roles/common/tasks/main.yml</code> должен получиться таким:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>useradd.yml<span style="color:#bbb">
</span><span style="color:#bbb">  </span>vars:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>ansible_user:<span style="color:#bbb"> </span>root<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>timezone.yml<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>upgrade.yml<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>docker.yml</code></pre></div>
<p>Теперь проверим, всё ли корректно отработает на сервере. Отредактируем файл <code>playbook.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>hosts:<span style="color:#bbb"> </span>webserver<span style="color:#bbb">
</span><span style="color:#bbb">  </span>gather_facts:<span style="color:#bbb"> </span>no<span style="color:#bbb">
</span><span style="color:#bbb">  </span>become:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>roles:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>common</code></pre></div>
<p>Ключ <code>become</code> означает, что задачи в ролях будут выполнены с правами пользователя <code>root</code> с помощью sudo, а <code>gather_facts</code> выключает сбор данных с хоста, нам они не нужны. Остальное, думаю, вопросов не вызывает. Запускаем плейбук следующей командой:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ ansible-playbook playbook.yml -i inventory.ini</code></pre></div>
<p><img src="/images/deployment-automation-tools/001.png" alt="" /></p>

<p>Статус <code>changed</code> показывает, что состояние было изменено. Если запустить команду повторно, то статус всех команд сменится на <code>ok</code>, ведь все задачи уже были выполнены и изменений не произошло.</p>

<p>Первый этап проекта можно считать завершённым, приступаем к деплою. Для работы веб приложения как минимум требуется программа веб-сервер, которая будет принимать HTTP-запросы от клиентов. В случае статического сайта этого будет достаточно, но бывает, что нужна ещё база данных, интерпретаторы кода и другие зависимости. Всё это требует дополнительной настройки. Для обеспечения предсказуемой работы принято использовать <a href="https://ru.wikipedia.org/wiki/Docker">Docker</a>. С его помощью можно собрать изолированное приложение, проверить работоспособность, доставить на сервер гарантированно рабочую и протестированную сборку не меняя при этом его внешней конфигурации.</p>

<p>Docker управляет независимыми контейнерами по одному, но если надо обеспечить взаимодействие нескольких друг с другом, то используется технология docker-compose. Конфигурационные файлы compose также описываются на языке YAML.</p>

<h3 id="доставка-приложения">Доставка приложения</h3>

<p>Создадим папку <code>roles/blog/files/app</code>, а в ней файл <code>docker-compose.yml</code> со следующим содержимым:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-docker" data-lang="docker">version: <span style="color:#4070a0">&#39;2&#39;</span><span style="">
</span><span style="">
</span><span style=""></span>services:<span style="">
</span><span style=""></span>  app:<span style="">
</span><span style=""></span>    image: nginx:latest<span style="">
</span><span style=""></span>    container_name: nginx<span style="">
</span><span style=""></span>    volumes:<span style="">
</span><span style=""></span>      - ./www:/var/www<span style="">
</span><span style=""></span>      - ./conf:/etc/nginx/conf.d<span style="">
</span><span style=""></span>    ports:<span style="">
</span><span style=""></span>      - <span style="color:#4070a0">&#34;80:80&#34;</span><span style="">
</span><span style=""></span>      - <span style="color:#4070a0">&#34;443:443&#34;</span><span style="">
</span><span style=""></span>    restart: always</code></pre></div>
<p>Там же создадим папку <code>www</code> в которой будут находится файлы приложения и <code>conf</code> с настройками веб сервера. Из структуры <code>docker-compose.yml</code> должно быть видно, что эти папки подключаются к контейнеру <code>nginx</code> и всё что мы положим туда будет доступно изнутри. Количество контейнеров может варьироваться в зависимости от приложения и всеми можно управлять через docker-compose.</p>

<p>Работу приложения можно проверить выполнив локально команду:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ docker-compose up</code></pre></div>
<p>Если всё устраивает, то попробуем запультнуть всё это добро на сервер. Создаём файл <code>roles/blog/tasks/push.yml</code> с разметкой:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>synchronization<span style="color:#bbb"> </span>using<span style="color:#bbb"> </span>rsync<span style="color:#bbb"> </span>protocol<span style="color:#bbb"> </span>(push)<span style="color:#bbb">
</span><span style="color:#bbb">  </span>synchronize:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>src:<span style="color:#bbb"> </span>app<span style="color:#bbb">
</span><span style="color:#bbb">    </span>dest:<span style="color:#bbb"> </span>/home/{{<span style="color:#bbb"> </span>username<span style="color:#bbb"> </span>}}/app</code></pre></div>
<p>Тут важно понимать, что <code>synchronize</code> далеко не единственный способ доставки файлов на сервер. Есть другие модули, есть git и так далее.</p>

<h3 id="управление-состоянием">Управление состоянием</h3>

<p>После того как файлы будут доставлены можно зайти на сервер и запустить docker-compose вручную, но с помощью Ansible мы можем управлять состоянием и поэтому сделаем так, чтоб приложение запускалось сразу после доставки.</p>

<p>Создадим файл <code>roles/blog/tasks/app_state.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>start<span style="color:#bbb"> </span>app<span style="color:#bbb">
</span><span style="color:#bbb">  </span>docker_service:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>project_src:<span style="color:#bbb"> </span>/home/{{<span style="color:#bbb"> </span>username<span style="color:#bbb"> </span>}}/app<span style="color:#bbb">
</span><span style="color:#bbb">    </span>services:<span style="color:#bbb">
</span><span style="color:#bbb">     </span>-<span style="color:#bbb"> </span>app<span style="color:#bbb">
</span><span style="color:#bbb">    </span>state:<span style="color:#bbb"> </span>present<span style="color:#bbb">
</span><span style="color:#bbb">  </span>register:<span style="color:#bbb"> </span>output<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>debug:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>var:<span style="color:#bbb"> </span>output</code></pre></div>
<p>Ansible имеет множество модулей для управления различными параметрами Docker. Использование <a href="http://docs.ansible.com/ansible/latest/modules/docker_service_module.html#docker-service-module">docker_service</a> целесообразно когда у вас уже есть написанный docker-compose файл или же вам надо описать взаимодействие между контейнерами с помощью собственной разметки Ansible. Если требуется обойтись без docker-compose, то можно использовать модуль <a href="http://docs.ansible.com/ansible/latest/modules/docker_container_module.html#docker-container-module">docker_container</a>, который больше подходит для управления независимыми контейнерами. Параметр <code>state</code> управляет состоянием, поменяв его значение на absent можно инициировать выполнение команды <code>docker-compose down</code> и остановить приложение. Каждый модуль Ansible помимо входящих параметров возвращает какие-то значения. Через параметр <code>register</code> можно сохранить эти значения в переменной и распечатывать их в момент выполнения через модуль <a href="http://docs.ansible.com/ansible/latest/modules/debug_module.html#debug-module">debug</a>. Бывает полезно.</p>

<h3 id="резервное-копирование-данных">Резервное копирование данных</h3>

<p>Как гласит народная мудрость админы делятся на два типа — тех, кто делает бекапы и тех, кто пока их не делает. Для организации резервного копирования воспользуемся популярным приложением Duplicity в связке с облачным хранилищем <a href="https://www.backblaze.com">Backblaze</a>.</p>

<p>Создадим файл <code>roles/blog/tasks/backup.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>install<span style="color:#bbb"> </span>duplicity<span style="color:#bbb">
</span><span style="color:#bbb">  </span>apt:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;{{ packages }}&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>update_cache:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">  </span>vars:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>packages:<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>duplicity<span style="color:#bbb">
</span><span style="color:#bbb">      </span>-<span style="color:#bbb"> </span>python-pip<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>install<span style="color:#bbb"> </span>b2<span style="color:#bbb"> </span>module<span style="color:#bbb">
</span><span style="color:#bbb">  </span>pip:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span>b2<span style="color:#bbb">
</span><span style="color:#bbb">    </span>executable:<span style="color:#bbb"> </span>pip</code></pre></div>
<p>По умолчанию Duplicity нужен модуль b2 для работы с Backblaze и я сразу учёл это. Бекапы будем делать по расписанию, поэтому создадим файл   <code>roles/blog/tasks/cron.yml</code> с содержимым:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb"> </span>daily<span style="color:#bbb"> </span>backup<span style="color:#bbb">
</span><span style="color:#bbb">  </span>cron:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>name:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;daily backup&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>minute:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;0&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>hour:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;3&#34;</span><span style="color:#bbb">
</span><span style="color:#bbb">    </span>job:<span style="color:#bbb"> </span><span style="color:#4070a0">&#34;PASSPHRASE={{ duplicity_password }} duplicity --allow-source-mismatch /home/{{ username }}/app b2://{{ b2_account_id }}:{{ b2_application_key }}@my-vps/app&#34;</span></code></pre></div>
<p>Секретные данные спрячем в переменных <code>groups_vars/all/vault.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">duplicity_password:<span style="color:#bbb"> </span>strongpassword<span style="color:#bbb">
</span><span style="color:#bbb"></span>b2_account_id:<span style="color:#bbb"> </span><span style="color:#40a070">1234</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>b2_application_key:<span style="color:#bbb"> </span><span style="color:#40a070">1234567890</span></code></pre></div>
<h3 id="выполнение-роли-blog">Выполнение роли Blog</h3>

<p>Импортируем все задачи в главный файл роли <code>roles/blog/tasks/main.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>push.yml<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>app_state.yml<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>backup.yml<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>-<span style="color:#bbb"> </span>name:<span style="color:#bbb">
</span><span style="color:#bbb">  </span>import_tasks:<span style="color:#bbb"> </span>cron.yml</code></pre></div>
<p>И подключим саму роль в <code>playbook.yml</code>:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yml" data-lang="yml">-<span style="color:#bbb"> </span>hosts:<span style="color:#bbb"> </span>webserver<span style="color:#bbb">
</span><span style="color:#bbb">  </span>gather_facts:<span style="color:#bbb"> </span>no<span style="color:#bbb">
</span><span style="color:#bbb">  </span>become:<span style="color:#bbb"> </span>yes<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>roles:<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>common<span style="color:#bbb">
</span><span style="color:#bbb">    </span>-<span style="color:#bbb"> </span>blog</code></pre></div>
<p>Можно запускать:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ ansible-playbook playbook.yml -i inventory.ini</code></pre></div>
<p>Если зайти на сервер по SSH, то можно увидеть, что всё отработало как надо.</p>

<p><img src="/images/deployment-automation-tools/002.png" alt="" />
<img src="/images/deployment-automation-tools/003.png" alt="" /></p>

<h3 id="безопасность">Безопасность</h3>

<p>Вроде бы всё сделано, но что если текущую конфигурацию необходимо выложить в публичный репозиторий на гитхабе? Делиться паролями со всеми желающими конечно не очень хочется. Для обеспечения безопасности секретных данных в Ansible предусмотрен соответствующий механизм <a href="https://docs.ansible.com/ansible/2.4/vault.html">Vault</a>.</p>

<p>Введём команду:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">ansible-vault encrypt group_vars/all/vault.yml</code></pre></div>
<p>Теперь файл <code>vault.yml</code> зашифрован, а его содержимое выглядит вот так:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt">$ANSIBLE_VAULT;1.1;AES256
66643934633963316635633761323962613563303139653039623630303232396430376665303439
6231333464616135326339383332633262343436373131640a663238663339336338386464656263
35363731353432383662306235393463336132313835623939633261396430376630623961303437
3339643334346366310a383766613435313931393638626463383566393431323036386231333466
63633638633033626662653835333130306132616535383938323237356463663433356266643131
33646261366464333137356532656232393564356165663565663237666663303438663263623036
62313434663735613538393463343563343634343833383066323663363262663236326439386131
37306466383566313863376535366465623937346162623735636636666536353065383330313933
32323162633361386639303061613032363233646265316564366239363037353433393961336265
66383530386232353634376435303431656137646531636464323637313738323738623832636435
32633635656133356430333433626636323438396135633366356334303432643463386666646435
65386132383739393331396139613764383833626630383135353965333462656436643539376161
38636137386239333837303061666237303465363338643463613566303565633432343630376436
33633137393337666133373934386130653463623835333433326635616237643266633733666564
306564633965363963643365396463636232</code></pre></div>
<p>Тем не менее ничего не сломается, а в случае когда потребуется расшифровать сделать это можно командой:</p>
<div class="highlight"><pre style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">$ ansible-vault decrypt group_vars/all/vault.yml</code></pre></div>
<p>Однако, будьте осторожны, есть риск забыть зашифровать и опубликовать как есть. Поэтому для редактирования зашифрованного файла лучше использовать команду <code>ansible-vault edit</code>.</p>

<p>В данной статье рассматриваются очень простые задачи Ansible и Docker. На практике приходится делать вещи сложнее, но принципы остаются теми же. Я использую эти инструменты для выкладки и управления такими приложениями как этот блог, почтовый сервер в связке с веб интерфейсом, openvpn и ikev2 серверы, mtproto telegram proxy сервер, медиасервер plex и многие другие. Больше примеров можно увидеть в моих публичных репозиториях на гитхабе:</p>

<ul>
<li><a href="https://github.com/snupt/vps-ansible">vps-ansible</a></li>
<li><a href="https://github.com/snupt/vps-app-blog">vps-app-blog</a></li>
<li><a href="https://github.com/snupt/vps-app-mailserver">vps-app-mailserver</a></li>
<li><a href="https://github.com/snupt/vps-app-rainloop">vps-app-rainloop</a></li>
<li><a href="https://github.com/snupt/vps-app-openvpn">vps-app-openvpn</a></li>
<li><a href="https://github.com/snupt/vps-app-ikev2">vps-app-ikev2</a></li>
<li><a href="https://github.com/snupt/vps-app-mtproto">vps-app-mtproto</a></li>
</ul>

</div>


<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "snupt" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>

    
    
<script type="text/javascript">
  var clicky_site_ids = clicky_site_ids || [];
  clicky_site_ids.push(100590268);
  (function() {
    var s = document.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = '//static.getclicky.com/js';
    ( document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0] ).appendChild( s );
  })();
</script>
<noscript><p><img alt="Clicky" width="1" height="1" src="//in.getclicky.com/100590268ns.gif" /></p></noscript>


<script type="text/javascript" > (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter26955852 = new Ya.Metrika({ id:26955852, clickmap:true, trackLinks:true, accurateTrackBounce:true }); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = "https://mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks"); </script> <noscript><div><img src="https://mc.yandex.ru/watch/26955852" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

  </body>
</html>